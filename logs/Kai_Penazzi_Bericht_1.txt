Im Rahmen der letzten zwei Wochen habe ich mich mit folgenden Themen besch√§ftigt:
    - Funktionsweise des QUIC-Protokolls
    - Recherche, welche Unternehmen derzeit bereits QUIC/HTTP3 einsetzen
    - Recherche zu verf√ºgbaren Frameworks und Bibliotheken in verschiedenen Programmiersprachen
    - Auswahl geeigneter Tools f√ºr Messungen und Analyse (tc, Wireshark)
    - Erste Server- und Client-Implementationen in Rust (gm-quic), inkl. Versenden einer Testnachricht

Funktionsweise des QUIC-Protokolls:
    - QUIC ist ein Transportprotokoll auf Schicht 4 und verwendet UDP als Tr√§ger
    - QUIC ersetzt funktional TCP + TLS und integriert zus√§tzliche Features wie 0-RTT
    - QUIC baut eine verschl√ºsselte Verbindung √ºber einen 1-RTT-Handshake auf; bei Wiederverbindungen sogar 0-RTT.
      Dadurch ben√∂tigt QUIC weniger Round-Trips als TCP + TLS in Kombination.

Vorteile:
    - 0-RTT und 1-RTT Handshake, dadurch geringere Latenz
    - Geringere Verz√∂gerung, da Transport und Verschl√ºsselung in einem Protokoll vereint sind
    - Multiplexing ohne Head-of-Line-Blocking
    - Verbindung bleibt stabil bei Netzwerkwechseln (Connection IDs statt IP/Port-Bindung)

Nachteile:
    - H√∂herer CPU-Verbrauch, da Verschl√ºsselung, Paketverwaltung und Verlustkorrektur nicht durch die Netzwerkkarte erfolgen
    - Debugging schwieriger, da auch Kontrollinformationen verschl√ºsselt sind
    - Netzwerkger√§te (Router/Firewalls) k√∂nnen weniger optimieren, da sie den Inhalt nicht einsehen k√∂nnen

Unternehmen die QUIC einsetzen:
    - Couldflare unterst√ºtzt seit 2021 http3 -> https://www.cloudflare.com/de-de/learning/performance/what-is-http3/ 13.11.
    - Amazon aws http3 -> https://aws.amazon.com/blogs/aws/new-http-3-support-for-amazon-cloudfront/ 13.11
    - Azure ddos quic support -> https://techcommunity.microsoft.com/blog/azurenetworksecurityblog/azure-ddos-protection-now-supports-quic-protocol-%E2%80%94-securing-the-future-of-http3-/4456522 13.11

Frameworks:
    - C#      ASP.NET Core http3 -> https://learn.microsoft.com/de-de/aspnet/core/fundamentals/servers/kestrel/http3?view=aspnetcore-9.0 13.11
    - C#      System.Net.Quic -> https://learn.microsoft.com/de-de/dotnet/fundamentals/networking/quic/quic-overview 13.11
    - Python  aioquic -> https://github.com/aiortc/aioquic 13.11
    - Java    HttpClient -> https://inside.java/2025/10/22/http3-support/ 13.11
    - Java    kwik -> https://github.com/ptrd/kwik 13.11
    - rust    quiche -> https://github.com/cloudflare/quiche 13.11
    - rust    gm-quic -> https://github.com/genmeta/gm-quic 13.11
    - c       msquic -> https://github.com/microsoft/msquic 13.11
    - c       lsquic -> https://github.com/litespeedtech/lsquic 13.11


Geeigneter Tools f√ºr Messungen und Tracking (tc, Wireshark)
    ChatGPT Frage: kannst du mir geeignete tools zum vergleichen eine quic und tcp Verbindung empfehlen, ich habe selber einen client und server gebaut. 14.11
    Ergebnis:
        Gute Frage! Es gibt mehrere Tools, mit denen du deine selbstgebauten QUIC- und TCP-Verbindungen vergleichen kannst ‚Äì je nachdem, was genau du messen willst (Latenz, Durchsatz, Paketverlust, Verbindungseinrichtung, etc.). Hier sind ein paar Empfehlungen + wie du sie einsetzen kannst:

        üîß Tools f√ºr den Vergleich TCP vs QUIC

        qperf
        - Speziell f√ºr QUIC gedacht, √§hnlich wie iperf f√ºr TCP.
        - Misst Durchsatz, Verbindungsaufbauzeit, Verlust.
        - Voraussetzung: TLS-Zertifikat, da QUIC TLS braucht.
        - Sehr n√ºtzlich, wenn du explizit QUIC-Messwerte hast und diese mit TCP vergleichen willst.

        QUIC / TCP Measurement Tool (qtm)
        - Ein kleines Go-Tool (‚Äûqtm‚Äú) aus dem Projekt bennyboer/quic-tcp-performance.
        - Unterst√ºtzt sowohl QUIC als auch TCP, wodurch du direkt compare kannst, indem du denselben Client/Server mit beiden Protokollen betreibst.
        - Flexibel: du kannst definieren, ob du eine bestimmte Menge Bytes senden willst (--bytes) oder √ºber eine bestimmte Zeit (--duration) mit Puffergr√∂√üen.

        qlog / qvis
        - qlog ist ein Standard-/Schema zum Loggen von QUIC-Verbindungsereignissen (z. B. Paket gesendet, verloren, Wiederholung, Congestion Window, RTT).
        - Viele QUIC-Implementierungen unterst√ºtzen qlog (z. B. quic-go).
        - Mit qvis kannst du diese Logs visuell aufbereiten: Sequenzdiagramme, Zeitachsen, Retransmits etc. Sehr hilfreich, um das Verhalten von QUIC intern zu verstehen.
        - Wenn du OpenSSL mit QUIC benutzt, kannst du openssl-qlog verwenden, um qlog-Dateien zu erzeugen.

        Netzwerk-Sniffer / Paketanalysatoren
        - netsniff-ng: Ein sehr leistungsf√§higes Toolkit f√ºr das Capturen und Analysieren von Netzwerkpaketen auf Linux.
        - Zusammen mit tcpdump oder Wireshark kannst du QUIC-Pakete (UDP + QUIC-Struktur) vs. TCP-Pakete analysieren ‚Äì z. B. um Round-Trip-Zeiten, Retransmits, Paketgr√∂√üen zu vergleichen.

        TCP-Benchmarking Tools
        Auch wenn du vor allem QUIC messen willst, brauchst du gutes TCP-Referenz-Benchmarking:

        - iperf / iperf3: Sehr verbreitet, einfach zu nutzen, misst Durchsatz (TCP & UDP) sehr zuverl√§ssig.
        - Flowgrind: Etwas fortgeschrittener, kann Transport-Layer-Metriken wie RTT, Congestion Window ausgeben.
        - tcptrace: Analyse von TCP-Verbindungen aus pcap-Dateien, zeigt u.a. Retransmits, Fenstergr√∂√üe, Durchsatz √ºber die Zeit.

        Benchmark-Frameworks
        - TQUIC: In deren Benchmark-Dokumentation gibt es Methoden, um QUIC-Implementationen zu testen unter verschiedenem Netzwerkbedingungen.
        - MsQuic Performance Dashboard: Wenn du Microsofts QUIC-Implementierung nutzt, kannst du ihre Performance-Tests + Metriken √ºber ihr Dashboard einsehen.

        ‚úÖ Empfehlung f√ºr deinen Use-Case

        Da du sagst, dass du einen eigenen Client und Server gebaut hast, w√ºrde ich dir folgenden Workflow vorschlagen:

        1. Messung des Durchsatzes / der Bandbreite
        - Starte deinen Server einmal mit QUIC, einmal mit TCP.
        - Verwende qperf, um den Durchsatz √ºber eine definierte Zeitspanne zu messen.
        - Parallel kannst du iperf3 f√ºr den TCP-Test laufen lassen.

        2. Verbindungsaufbauzeiten & Latenz
        - Miss mit qperf wie lange der Verbindungsaufbau (Handshake) dauert (--e-Flag in qperf f√ºr ‚Äûtime to first byte‚Äú).
        - Nutze qlog bei deinen QUIC-Verbindungen (je nach QUIC-Implementierung) und analysiere mit qvis die Ereignisse ‚Äì das hilft dir, zu sehen, wann Pakete gesendet werden, wann ACKs kommen etc.

        3. Fehlerszenarien / Stabilit√§t
        - Emuliere Netzwerkbedingungen (Verlust, Verz√∂gerung, Jitter) ‚Äì z. B. mit Traffic Control (tc) auf Linux oder in einer Testumgebung.
        - F√ºhre deine Messungen unter diesen Bedingungen durch (wieder mit qperf + iperf).
        - Capturiere den Verkehr mit netsniff-ng oder tcpdump, um zu analysieren, wie QUIC vs TCP reagiert.

        4. Tieferes Debug / Verhalten
        - Logge intern mit qlog, wenn deine QUIC-Implementierung das unterst√ºtzt.
        - Visualisiere Verbindungsereignisse mit qvis, um zu verstehen, wie sich Congestion Window, Loss Recovery, Streams etc. verhalten.

        Wenn du magst, kann ich dir ein fertiges Benchmark-Skript schreiben (z. B. in Bash oder Python), das all diese Messungen automatisiert (QUIC vs TCP, Latenz, Durchsatz, Verlust). Soll ich das machen?

N√§chste Schritte:
    - Eine Implementierung in Java mit dem Kwik Framework erstellen
    - Oben genannte Tools ausprobieren (und tc).
